API Analysis for MCP Tool Generation

This guide explains how to analyze API documentation and endpoints to create effective MCP tools and resources.

API Analysis Principles

1. Endpoint Classification
Classify API endpoints into logical categories:

CRUD Operations:
- GET /items → List/search tool
- GET /items/{id} → Retrieve tool + resource
- POST /items → Create tool
- PUT /items/{id} → Update tool
- DELETE /items/{id} → Delete tool

Special Operations:
- POST /items/{id}/actions → Action tools
- GET /items/{id}/relationships → Relationship tools/resources
- POST /auth/login → Authentication tools

2. Parameter Analysis

Path Parameters:

{
  "path": "/users/{user_id}/repos/{repo_id}",
  "parameters": [
    {"name": "user_id", "type": "string", "required": true},
    {"name": "repo_id", "type": "string", "required": true}
  ]
}

→ Creates tool with required string parameters

Query Parameters:

{
  "parameters": [
    {"name": "per_page", "type": "integer", "default": 30, "max": 100},
    {"name": "page", "type": "integer", "default": 1},
    {"name": "sort", "type": "string", "enum": ["created", "updated", "name"]},
    {"name": "order", "type": "string", "enum": ["asc", "desc"]}
  ]
}

→ Creates tool input schema with proper validation

Body Parameters:

{
  "body": {
    "type": "object",
    "properties": {
      "name": {"type": "string", "required": true},
      "description": {"type": "string"},
      "private": {"type": "boolean", "default": false}
    }
  }
}

→ Creates nested object parameters in tool schema

3. Response Analysis

Successful Responses:
- 200 OK → Standard tool response
- 201 Created → Creation tool with success indication
- 204 No Content → Deletion tool with confirmation message

Error Responses:
- 400 Bad Request → Parameter validation needed
- 401 Unauthorized → Authentication required
- 403 Forbidden → Permission checks needed
- 404 Not Found → Resource existence validation
- 429 Rate Limited → Rate limiting considerations

Tool Generation Guidelines

For GET Endpoints (Data Retrieval)

Single Item Retrieval:

// GET /users/{user_id}
export const getUserTool = {
  name: 'get_user',
  description: 'Retrieve user information by ID',
  inputSchema: {
    type: 'object',
    properties: {
      user_id: {
        type: 'string',
        description: 'The user ID to retrieve'
      }
    },
    required: ['user_id']
  }
};

List/Search Operations:

// GET /users?q=search&sort=created&order=desc
export const searchUsersTool = {
  name: 'search_users',
  description: 'Search for users with optional filters',
  inputSchema: {
    type: 'object',
    properties: {
      q: {
        type: 'string',
        description: 'Search query'
      },
      sort: {
        type: 'string',
        enum: ['repositories', 'followers', 'joined'],
        description: 'Sort field'
      },
      order: {
        type: 'string',
        enum: ['asc', 'desc'],
        description: 'Sort order'
      },
      per_page: {
        type: 'integer',
        minimum: 1,
        maximum: 100,
        description: 'Results per page'
      },
      page: {
        type: 'integer',
        minimum: 1,
        description: 'Page number'
      }
    },
    required: ['q']
  }
};

For POST Endpoints (Data Creation)

// POST /repos
export const createRepoTool = {
  name: 'create_repository',
  description: 'Create a new repository',
  inputSchema: {
    type: 'object',
    properties: {
      name: {
        type: 'string',
        description: 'Repository name'
      },
      description: {
        type: 'string',
        description: 'Repository description'
      },
      private: {
        type: 'boolean',
        description: 'Whether the repository is private',
        default: false
      },
      has_issues: {
        type: 'boolean',
        description: 'Enable issues for this repository',
        default: true
      },
      has_wiki: {
        type: 'boolean',
        description: 'Enable wiki for this repository',
        default: true
      },
      auto_init: {
        type: 'boolean',
        description: 'Initialize repository with README',
        default: false
      }
    },
    required: ['name']
  }
};

For PUT/PATCH Endpoints (Data Updates)

// PATCH /repos/{owner}/{repo}
export const updateRepoTool = {
  name: 'update_repository',
  description: 'Update repository settings',
  inputSchema: {
    type: 'object',
    properties: {
      owner: {
        type: 'string',
        description: 'Repository owner'
      },
      repo: {
        type: 'string',
        description: 'Repository name'
      },
      name: {
        type: 'string',
        description: 'New repository name'
      },
      description: {
        type: 'string',
        description: 'New repository description'
      },
      private: {
        type: 'boolean',
        description: 'Update repository visibility'
      },
      has_issues: {
        type: 'boolean',
        description: 'Enable/disable issues'
      },
      has_wiki: {
        type: 'boolean',
        description: 'Enable/disable wiki'
      }
    },
    required: ['owner', 'repo']
  }
};

For DELETE Endpoints

// DELETE /repos/{owner}/{repo}
export const deleteRepoTool = {
  name: 'delete_repository',
  description: 'Delete a repository (permanent action)',
  inputSchema: {
    type: 'object',
    properties: {
      owner: {
        type: 'string',
        description: 'Repository owner'
      },
      repo: {
        type: 'string',
        description: 'Repository name to delete'
      },
      confirm: {
        type: 'boolean',
        description: 'Confirmation that you want to delete this repository',
        default: false
      }
    },
    required: ['owner', 'repo', 'confirm']
  }
};

Resource Generation Guidelines

Static Resources (Fixed Data)

// For /meta endpoint or similar
export const apiMetaResource = {
  uri: 'api://meta',
  name: 'API Metadata',
  description: 'API version, rate limits, and metadata',
  mimeType: 'application/json'
};

Template Resources (Parameterized)

// For /users/{user_id} as a resource
export const userProfileResource = {
  uri: 'user://{user_id}',
  name: 'User Profile',
  description: 'Complete user profile information',
  mimeType: 'application/json'
};

// For /repos/{owner}/{repo}
export const repositoryResource = {
  uri: 'repo://{owner}/{repo}',
  name: 'Repository Details',
  description: 'Complete repository information and metadata',
  mimeType: 'application/json'
};

List Resources (Collections)

// For endpoints that return lists
export const userRepositoriesResource = {
  uri: 'user://{user_id}/repositories',
  name: 'User Repositories',
  description: 'List of repositories owned by the user',
  mimeType: 'application/json'
};

Authentication Analysis

API Key Authentication

// Headers-based authentication
const headers = {
  'Authorization': Bearer ${process.env.API_TOKEN},
  'Accept': 'application/vnd.api+json'
};

OAuth2 Authentication

// OAuth2 flow analysis
// → Create separate authentication tools
export const getAccessTokenTool = {
  name: 'get_access_token',
  description: 'Exchange authorization code for access token',
  inputSchema: {
    type: 'object',
    properties: {
      code: {
        type: 'string',
        description: 'Authorization code from OAuth2 flow'
      },
      redirect_uri: {
        type: 'string',
        description: 'Redirect URI used in authorization'
      }
    },
    required: ['code', 'redirect_uri']
  }
};

Performance Considerations

Rate Limiting Analysis
- Identify rate limits from API documentation
- Add appropriate delays in tool handlers
- Implement exponential backoff for retries
- Cache responses where appropriate

Pagination Handling

// For paginated endpoints
export const getAllItemsTool = {
  name: 'get_all_items',
  description: 'Retrieve all items across multiple pages',
  inputSchema: {
    type: 'object',
    properties: {
      max_pages: {
        type: 'integer',
        minimum: 1,
        maximum: 10,
        description: 'Maximum number of pages to fetch',
        default: 3
      },
      per_page: {
        type: 'integer',
        minimum: 1,
        maximum: 100,
        description: 'Items per page',
        default: 30
      }
    },
    required: []
  }
};

Security Analysis

Sensitive Data Handling
- Identify endpoints that return sensitive information
- Implement proper filtering in tool responses
- Never log sensitive data
- Use environment variables for credentials

Permission Requirements
- Document required scopes/permissions for each tool
- Implement proper error handling for insufficient permissions
- Group tools by permission requirements

Tool Naming Conventions

Consistent Naming Patterns
- get_* for single item retrieval
- list_* or search_* for collections
- create_* for POST operations
- update_* for PUT/PATCH operations
- delete_* for DELETE operations
- *_action for special operations

Resource Naming Patterns
- api://endpoint for API metadata
- item://{id} for single items
- collection://type for collections
- user://{user_id}/resource for user-scoped resources

This analysis framework ensures comprehensive coverage of API capabilities while maintaining consistency and usability in the generated MCP tools and resources.
