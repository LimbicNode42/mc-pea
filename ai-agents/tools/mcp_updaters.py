"""
MCP Template Updater Tools for MCP API Integrator Agent

These tools update the MCP server template files (tools/index.ts and resources/index.ts) 
with generated TypeScript code.
"""

import os
import logging
from typing import Type
from pydantic import BaseModel, Field
from crewai.tools import BaseTool

logger = logging.getLogger(__name__)


class UpdateMCPToolsIndexInput(BaseModel):
    """Input schema for UpdateMCPToolsIndexTool."""
    tool_name: str = Field(
        ..., 
        description="Name of the tool being added (e.g., 'get_user_profile'). Should match the tool definition."
    )
    tool_code: str = Field(
        ..., 
        description="""Complete TypeScript code for the tool, including both definition and handler.
        Should be in the format:
        // Tool Definition for tool_name
        tool_name: { ... },
        
        // Tool Handler for tool_name  
        tool_name: async (args, sessionId) => { ... }"""
    )
    server_path: str = Field(
        default="",
        description="Path to the MCP server directory. If empty, will use the agent's configured server path."
    )


class UpdateMCPToolsIndexTool(BaseTool):
    name: str = "update_mcp_tools_index"
    description: str = """
    Update the MCP server's tools/index.ts file with a new tool definition and handler.
    
    This tool:
    1. Reads the existing tools/index.ts file (or creates from template)
    2. Parses the provided tool code to extract definition and handler
    3. Adds the tool definition to the toolDefinitions export
    4. Adds the tool handler to the toolHandlers export
    5. Writes the updated file back
    
    The tool code should be generated by the generate_typescript_tool tool.
    This follows the MCP template pattern for organizing tools.
    
    Use this after generating TypeScript tool code to integrate it into the MCP server.
    """
    args_schema: Type[BaseModel] = UpdateMCPToolsIndexInput

    def _run(self, tool_name: str, tool_code: str, server_path: str = "") -> str:
        """Update the tools/index.ts file with new tool definition and handler."""
        logger.debug(f"ðŸ› ï¸ UpdateMCPToolsIndexTool._run called with tool_name={tool_name}")
        
        try:
            # Determine server path
            if not server_path:
                # Try to get from agent context or use default
                server_path = os.path.abspath(os.path.join('..', 'mcp-servers', 'generated-server'))
            
            tools_index_path = os.path.join(server_path, 'src', 'tools', 'index.ts')
            logger.debug(f"ðŸ› ï¸ Tools index path: {tools_index_path}")
            
            # Read existing file or create from template
            if os.path.exists(tools_index_path):
                with open(tools_index_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                logger.debug(f"ðŸ› ï¸ Read existing tools index with {len(content)} characters")
            else:
                # Copy from template if available
                template_tools_path = os.path.join(
                    os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 
                    'templates', 'mcp-server-template', 'src', 'tools', 'index.ts'
                )
                
                if os.path.exists(template_tools_path):
                    with open(template_tools_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    logger.debug(f"ðŸ› ï¸ Copied template tools index")
                else:
                    # Fallback template
                    content = '''/**
 * Tool Definitions and Handlers
 * 
 * This file contains tool definitions and their corresponding handlers.
 * Generated tools are added here automatically.
 */

// Tool Definitions (JSON Schema format)
export const toolDefinitions = {
  // Generated tool definitions will be added here
};

// Tool Handlers
export const toolHandlers = {
  // Generated tool handlers will be added here
};
'''
                    logger.debug(f"ðŸ› ï¸ Created fallback tools index template")
            
            # Parse the tool_code to extract definition and handler
            if tool_code and '// Tool Definition' in tool_code and '// Tool Handler' in tool_code:
                lines = tool_code.split('\n')
                definition_lines = []
                handler_lines = []
                current_section = None
                
                for line in lines:
                    if line.strip().startswith('// Tool Definition'):
                        current_section = 'definition'
                        continue
                    elif line.strip().startswith('// Tool Handler'):
                        current_section = 'handler'
                        continue
                    elif line.strip() and not line.strip().startswith('//'):
                        if current_section == 'definition':
                            definition_lines.append(line)
                        elif current_section == 'handler':
                            handler_lines.append(line)
                
                definition_code = '\n'.join(definition_lines).strip()
                handler_code = '\n'.join(handler_lines).strip()
                
                # Remove trailing comma from definition if present
                if definition_code.endswith(','):
                    definition_code = definition_code[:-1]
                
                # Remove trailing comma from handler if present  
                if handler_code.endswith(','):
                    handler_code = handler_code[:-1]
                
                # Add tool definition to toolDefinitions
                if definition_code and '// Generated tool definitions will be added here' in content:
                    content = content.replace(
                        '// Generated tool definitions will be added here',
                        f'{definition_code},\n  // Generated tool definitions will be added here'
                    )
                    logger.debug(f"ðŸ› ï¸ Added tool definition for {tool_name}")
                
                # Add tool handler to toolHandlers  
                if handler_code and '// Generated tool handlers will be added here' in content:
                    content = content.replace(
                        '// Generated tool handlers will be added here',
                        f'{handler_code},\n  // Generated tool handlers will be added here'
                    )
                    logger.debug(f"ðŸ› ï¸ Added tool handler for {tool_name}")
                
                logger.debug(f"ðŸ› ï¸ Added structured tool {tool_name} to index")
            else:
                # Fallback for direct registration code - just append
                content += f'\n\n// {tool_name} tool registration\n{tool_code}\n'
                logger.debug(f"ðŸ› ï¸ Added direct tool {tool_name} to index")
            
            # Write back to file
            os.makedirs(os.path.dirname(tools_index_path), exist_ok=True)
            with open(tools_index_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.debug(f"ðŸ› ï¸ Successfully updated tools index")
            return f"Successfully updated tools index with '{tool_name}' at {tools_index_path}"
            
        except Exception as e:
            error_msg = f"Error updating tools index: {str(e)}"
            logger.error(f"ðŸ› ï¸ {error_msg}")
            return error_msg


class UpdateMCPResourcesIndexInput(BaseModel):
    """Input schema for UpdateMCPResourcesIndexTool."""
    resource_name: str = Field(
        ..., 
        description="Name of the resource being added (e.g., 'user_profile'). Should match the resource definition."
    )
    resource_code: str = Field(
        ..., 
        description="""Complete TypeScript code for the resource, including both definition and handler.
        Should be in the format:
        // Resource Definition for resource_name
        resource_name: { ... },
        
        // Resource Handler for resource_name
        "api://resource_name": async (sessionId) => { ... }"""
    )
    server_path: str = Field(
        default="",
        description="Path to the MCP server directory. If empty, will use the agent's configured server path."
    )


class UpdateMCPResourcesIndexTool(BaseTool):
    name: str = "update_mcp_resources_index"
    description: str = """
    Update the MCP server's resources/index.ts file with a new resource definition and handler.
    
    This tool:
    1. Reads the existing resources/index.ts file (or creates from template)
    2. Parses the provided resource code to extract definition and handler
    3. Adds the resource definition to the resourceDefinitions export
    4. Adds the resource handler to the resourceHandlers export
    5. Writes the updated file back
    
    The resource code should be generated by the generate_typescript_resource tool.
    This follows the MCP template pattern for organizing resources.
    
    Use this after generating TypeScript resource code to integrate it into the MCP server.
    """
    args_schema: Type[BaseModel] = UpdateMCPResourcesIndexInput

    def _run(self, resource_name: str, resource_code: str, server_path: str = "") -> str:
        """Update the resources/index.ts file with new resource definition and handler."""
        logger.debug(f"ðŸ”— UpdateMCPResourcesIndexTool._run called with resource_name={resource_name}")
        
        try:
            # Determine server path
            if not server_path:
                # Try to get from agent context or use default
                server_path = os.path.abspath(os.path.join('..', 'mcp-servers', 'generated-server'))
            
            resources_index_path = os.path.join(server_path, 'src', 'resources', 'index.ts')
            logger.debug(f"ðŸ”— Resources index path: {resources_index_path}")
            
            # Read existing file or create from template
            if os.path.exists(resources_index_path):
                with open(resources_index_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                logger.debug(f"ðŸ”— Read existing resources index with {len(content)} characters")
            else:
                # Copy from template if available
                template_resources_path = os.path.join(
                    os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 
                    'templates', 'mcp-server-template', 'src', 'resources', 'index.ts'
                )
                
                if os.path.exists(template_resources_path):
                    with open(template_resources_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    logger.debug(f"ðŸ”— Copied template resources index")
                else:
                    # Fallback template
                    content = '''/**
 * Resource Definitions and Handlers
 * 
 * This file contains resource definitions and their corresponding handlers.
 * Generated resources are added here automatically.
 */

// Resource Definitions
export const resourceDefinitions = {
  // Generated resource definitions will be added here
};

// Resource Handlers
export const resourceHandlers = {
  // Generated resource handlers will be added here
};
'''
                    logger.debug(f"ðŸ”— Created fallback resources index template")
            
            # Parse the resource_code to extract definition and handler
            if resource_code and '// Resource Definition' in resource_code and '// Resource Handler' in resource_code:
                lines = resource_code.split('\n')
                definition_lines = []
                handler_lines = []
                current_section = None
                
                for line in lines:
                    if line.strip().startswith('// Resource Definition'):
                        current_section = 'definition'
                        continue
                    elif line.strip().startswith('// Resource Handler'):
                        current_section = 'handler'
                        continue
                    elif line.strip() and not line.strip().startswith('//'):
                        if current_section == 'definition':
                            definition_lines.append(line)
                        elif current_section == 'handler':
                            handler_lines.append(line)
                
                definition_code = '\n'.join(definition_lines).strip()
                handler_code = '\n'.join(handler_lines).strip()
                
                # Remove trailing comma from definition if present
                if definition_code.endswith(','):
                    definition_code = definition_code[:-1]
                
                # Remove trailing comma from handler if present  
                if handler_code.endswith(','):
                    handler_code = handler_code[:-1]
                
                # Add resource definition to resourceDefinitions
                if definition_code and '// Generated resource definitions will be added here' in content:
                    content = content.replace(
                        '// Generated resource definitions will be added here',
                        f'{definition_code},\n  // Generated resource definitions will be added here'
                    )
                    logger.debug(f"ðŸ”— Added resource definition for {resource_name}")
                
                # Add resource handler to resourceHandlers  
                if handler_code and '// Generated resource handlers will be added here' in content:
                    content = content.replace(
                        '// Generated resource handlers will be added here',
                        f'{handler_code},\n  // Generated resource handlers will be added here'
                    )
                    logger.debug(f"ðŸ”— Added resource handler for {resource_name}")
                
                logger.debug(f"ðŸ”— Added structured resource {resource_name} to index")
            else:
                # Fallback for direct registration code - just append
                content += f'\n\n// {resource_name} resource registration\n{resource_code}\n'
                logger.debug(f"ðŸ”— Added direct resource {resource_name} to index")
            
            # Write back to file
            os.makedirs(os.path.dirname(resources_index_path), exist_ok=True)
            with open(resources_index_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            logger.debug(f"ðŸ”— Successfully updated resources index")
            return f"Successfully updated resources index with '{resource_name}' at {resources_index_path}"
            
        except Exception as e:
            error_msg = f"Error updating resources index: {str(e)}"
            logger.error(f"ðŸ”— {error_msg}")
            return error_msg
